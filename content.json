{"meta":{"title":"Humbert's Blog","subtitle":"欲变世界，先变自身","description":"一条咸鱼","author":"Humbert Zhang","url":"http://Humbertzhang.github.io"},"pages":[{"title":"","date":"2017-12-22T04:54:08.006Z","updated":"2017-12-22T04:54:07.994Z","comments":false,"path":"tags/index.html","permalink":"http://Humbertzhang.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-11T11:19:57.000Z","updated":"2017-12-11T12:05:26.245Z","comments":true,"path":"about/index.html","permalink":"http://Humbertzhang.github.io/about/index.html","excerpt":"","text":"A Student from CCNU, Wuhan, China. A Backend programmer,Developing with Python and its web frame like Flask and aiohttp. Also Be interested in Docker &amp; container. Email -&gt; 504490160 AT qq.com"}],"posts":[{"title":"CSAPP信息的表示与处理","slug":"CSAPP信息的表示与处理","date":"2017-12-20T06:15:47.000Z","updated":"2017-12-22T05:24:19.928Z","comments":true,"path":"2017/12/20/CSAPP信息的表示与处理/","link":"","permalink":"http://Humbertzhang.github.io/2017/12/20/CSAPP信息的表示与处理/","excerpt":"","text":"信息存储字数据大小为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，IOSC99引入了一类数据类型，其数据大小在不同机器上是固定的，不随编译器与机器设置而改变。如int32_t, int64_t, uint32_t, uint64_t等. 寻址和字节顺序假设一个程序中的对象由w位的数字来表示，且w是8的倍数(一个Byte是8个bit),那么就把它从最高位到最低位每8个划成一个字节。在存储时，有的机器采用从最低有效位到最高有效位来存储(小端法)，有的则相反(大端法),这两种方法没有性能上的差别，只是方式不同。Linux 与 Windows都使用小端法来储存数据。 二进制代码迁移性将一段程序经过编译后可以发现，在不同的机器上会得到不同的二进制代码，因为不同的操作系统对指令的编码规则是不一样的，因此二进制编码很难在不同的操作系统上兼容。 位级运算与、或、非、异或被成为位(bit)级运算.确定一个位级运算的结果的最好方法就是将其转化为二进制数，进行计算后再转化回来。一个利用异或特性来实现inplace_swap的算法如下:12345void inplace_swap(int *x, int *y)&#123; *y = *x ^ *y; *x = *x ^ *y; //*x = *x ^ *x ^ *y = *y *y = *x ^ *y; //*y = *y ^ *x ^ *y = *x&#125; 不过这种方式并没有性能上的优势。 逻辑运算在逻辑运算中，所有非0的参数表示True, 0表示False.并且，如果对一个参数求值，如if(A || B), 如果只运算A就可以得到确定的结果，那么B就不会被运算。因此我认为在写程序时要注意，最好不要将对程序结果有影响的式子放在逻辑运算中。 移位运算左移：在右端补0逻辑右移：在左端补0算数右移：在左端补最高有效位的值。对有符号整数的运算很实用。对绝大多数编译器，对有符号数进行算数右移，对无符号数进行逻辑右移。 整数表示无符号数编码可以用向量的思想来理解，每一位都是一个长度为2^i次方的向量，则无符号数字的值即为每一位向量的和。 有符号数的补码编码对于一个w位的向量 x = [Xw-1, Xw-2, Xw-3 ... X0], 第一位为符号位，权重为(-2^w-1)，而这个值足够大到加上之后的所有正数还是负数。因此符号位为1时，值为负，为0时，值为正。 则最小数为：-2^w-1, 即为只有第一位为1的，其他都为0的情况。最大数为:[01111…]情况，此时为2^w-2 + 2^w-3 + ... + 2^0, 即为2^w-1-1因此Min = -(Max+1), 且UnsignedMax = 2*MaX + 1 有符号数和无符号数的之间的转换","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://Humbertzhang.github.io/tags/CSAPP/"},{"name":"CS基础","slug":"CS基础","permalink":"http://Humbertzhang.github.io/tags/CS基础/"}]},{"title":"CPP STL介绍","slug":"CPP容器","date":"2017-12-11T06:53:36.000Z","updated":"2017-12-22T05:24:09.776Z","comments":true,"path":"2017/12/11/CPP容器/","link":"","permalink":"http://Humbertzhang.github.io/2017/12/11/CPP容器/","excerpt":"","text":"STL介绍STL(Standard Template Library), 标准模板库， 是一个具有工业强度的，高效的C++ 程序库。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 在C++标准中，STL被组织为下面的13个头文件： &lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;， &lt;vector&gt;， &lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;和&lt;utility&gt;。 STL 六大组件有容器、迭代器、算法、仿函数、迭代适配器、空间配置器。容器通过空间配置器取得数据存储空间；算法利用迭代器向容器存取数据；仿函数协助算法完成不同的策略；适配器可以用来修改容器、迭代器或仿函数的接口； 主要需要我们关注的有： 容器(Container): 是一种数据结构，如 list，vector，和deques ，以模板类的方法提供。 迭代器（Iterator）: 提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 算法(Algorithm): 用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用。 任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)。也就是说实际上，整个区间是从first开始到last-1，迭代器last指的是最后一个元素的下一个位置。在STL中所有区间都是采用前闭后开，这样可以带来很多方便。 常用容器与算法介绍常用容器&lt;vector&gt;vector是一个能够存放任意类型的动态数组。当你不知道需要选取什么容器时就选它吧。vector在储存空间不足时会开辟一个原空间*2大小的空间，并将原数据拷贝到新的空间中。这个操作比较耗时，但是有办法可以弥补这个缺点，在下文会有。 &lt;list&gt;双向循环链表。不可以随机存储，但是在任何地方插入与删除元素的时间都是常量. &lt;queue&gt;队列, 先进先出的数据结构.#/media/File:Data_Queue.svg) &lt;deque&gt;Deque是一个双向队列，既支持随机存取(像数组一样)，又支持两端的操作(在前后插入，在前后删除). &lt;priority_queue&gt;优先队列，即堆。每次出队的元素为优先级最高的那一个。 &lt;stack&gt;栈， 后进先出的数据结构。#/media/File:Lifo_stack.png) &lt;set&gt;set, multiset, map, multimap底层都是使用红黑树实现的。集合，每个值都是惟一的。 &lt;multiset&gt;多集，值可以重复，可以记录每个元素出现了多少次。 &lt;map&gt;键值对，键唯一，一个键对应一个值。 &lt;multimap&gt;键值对，键位移，一个键可对应多个值。 常用算法包含在&lt;algorithm&gt;头文件中 min(), max()返回最小值，最大值. sort()排序算法，将指定区间中的数据排序。如sort(v.begin(), v.end())会将v这个vector中的元素从小到大排列。还可以指定一个自己的比较规则作为参数传入sort函数。sort(v.begin(), v.end(), compare) reverse()反转算法, 将指定区间中的数据反转。reverse(s.begin(), s.end()) 会将s这个字符串反转。 swap()交换两个对象。 fill()对一个区间内的每个对象赋值。 unique()移除一个区间内的重复的对象。 copy()将一个区间内的数值拷贝到另一个区间中。 replace()将一个区间内的某个对象替换为另一个对象。 示例程序vector &amp; algorithm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void coutvec(vector&lt;int&gt; v)&#123; cout &lt;&lt; \"Vector 输出:\" &lt;&lt; endl; for(int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; \"\\r\\n\\r\\n\";&#125;int main()&#123; vector&lt;int&gt; v; v.reserve(20); for(int i = 20; i &gt; 0; i--)&#123; v.push_back(i); &#125; coutvec(v); cout &lt;&lt; \"reverse(v.begin()+10, v.end()+20):\" &lt;&lt; endl; reverse(v.begin()+10, v.begin()+20); coutvec(v); cout &lt;&lt; \"sort(v.begin(), v.end()):\" &lt;&lt;endl; sort(v.begin(), v.end()); coutvec(v); cout &lt;&lt; \"fill(v.begin(), v.begin+5, -1):\" &lt;&lt;endl; fill(v.begin(), v.begin()+5, -1); coutvec(v); cout &lt;&lt; \"copy(v.begin(), v.begin()+5, v.begin()+6):\" &lt;&lt;endl; copy(v.begin(), v.begin()+5, v.begin()+5); coutvec(v); cout &lt;&lt; \"replace(v.begin(), v.begin()+5, -1, 233):\" &lt;&lt; endl; replace(v.begin(), v.begin()+5, -1, 233); coutvec(v); cout &lt;&lt; \"unique(v.begin(), v.end()):\" &lt;&lt;endl; std::vector&lt;int&gt;::iterator it; it = unique(v.begin(), v.end()); v.resize(distance(v.begin(), it)); coutvec(v); return 0;&#125; Queue &amp; Stack12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Queue:\" &lt;&lt;endl; queue&lt;int&gt; q; for(int i = 1; i &lt;= 10; i++) &#123; q.push(i); &#125; while(!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; \" \"; q.pop(); &#125; cout &lt;&lt; \"\\r\\n\\r\\n\" &lt;&lt; endl; cout &lt;&lt; \"Stack:\" &lt;&lt;endl; stack&lt;int&gt; s; for(int i = 1; i &lt;= 10; i++) &#123; s.push(i); &#125; while(!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; \" \"; s.pop(); &#125; cout &lt;&lt; endl;&#125; Map &amp; Multimap 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Map:\" &lt;&lt;endl; map&lt;char, string&gt; m; m['a'] = \"apple\"; m['b'] = \"banana\"; m['c'] = \"cheery\"; std::map&lt;char, string&gt;::iterator it; for(it = m.begin(); it != m.end(); ++it) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \"=&gt;\" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; \"\\r\\n\\r\\n\" &lt;&lt; endl; cout &lt;&lt; \"MultiMap:\" &lt;&lt;endl; multimap&lt;char, string&gt; mm; mm.insert(make_pair('a', \"apple\")); mm.insert(make_pair('a', \"avocado\")); mm.insert(make_pair('b', \"banana\")); mm.insert(make_pair('b', \"berry\")); mm.insert(make_pair('b', \"blueberry\")); mm.insert(make_pair('c', \"cherry\")); mm.insert(make_pair('c', \"core\")); mm.insert(make_pair('c', \"chestnut\")); mm.insert(make_pair('c', \"cumquat\")); multimap&lt;char, string&gt;::iterator itlow, ithigh; itlow = mm.lower_bound('a'); ithigh = mm.upper_bound('c'); for(it = itlow; it!=ithigh; ++it)&#123; cout &lt;&lt; (*it).first &lt;&lt; \"=&gt;\" &lt;&lt; (*it).second &lt;&lt; endl; &#125; return 0;&#125; STL的选取 是否需要在容器任意位置插入新元素？如果需要，就选择序列容器(vector, string, deque, list)，避免关联容器(set, multiset, map, multimap) 你是否关心容器中的元素是如何排序的？若不关心最好选择hash容器如hashset, hashmap等，因为效率会更高。采用hash算法处理过的容器在查找元素时效率比普通容器更高 当容器发生元素插入与删除时，若需要尽力避免原来元素的腾挪，则应选择采用节点存储元素的容器(如list)，避免采用数组存储的元素如(vector)。 若十分关心容器的查找速度，则考虑的优先级为：hash容器， 排序的vector, 标准关联容器。 … … 使用技巧用empty()而非size()来检查容器是否为空对于所有容器，empty()都使用常数时间，而对于某些容器，size()需要耗费线性时间。 当在容器中存放指针时，注意在销毁容器前先销毁指针因为简单地delete容器并不能delete掉内部的那些指针。 删除如果你想删除某个值的元素，不同容器需要采用不同的方法。 如果采用连续内存容器，最好使用earse-remove方法. 1v.erase(remove(v.begin(), v.end(), 1), c.end()); 对于list, 最有效的是直接使用list的remove成员函数。 1c.remove(1); 对于关联容器，最有效的方法是使用erase 1c.erase(1); 如果你不只像删除某个值的元素，而是想删除下面这个函数返回false的函数。1bool shouldremove(val x) 对于序列容器(vector, list, deque, string), 只需要将remove 换为remove_if() 12345//c为vector, list, deque, stringc.erase(remove_if(c.begin(), c.end(), shouldremove), c.end());//c为listc.remove_if(shouldremove); 对于关联容器，最好采用这种方法 12345678Container&lt;int&gt; c;//遍历整个容器中的元素.for(Container::iterator i = c.begin(); i != end(); /*nothing*/)&#123; if(shouldremove(*i))&#123; c.earse(i); &#125; i++;&#125; Vector 减少不必要的重新分配vector的扩张可以分为下面几个步骤: 分配一块大小为当前容量2倍的空间。 把容器的所有元素从旧的内存拷贝到新的内存中。 析构掉旧内存中的对象。 释放旧的内存。这个过程是十分耗时的。 在想一下，如果你这样创建一个包含1到1000的vector, 你可能会这样做:1234vector&lt;int&gt; v;for (int i = 1; i &lt;= 1000; i++) &#123; v.push_back(i);&#125; 在这个过程中，最坏情况下会有10次内存重新分配。（1000 约等于 2的10次方）. 如何避免这种情况呢？vector提供了一个reserve函数， 这个函数可以将容器的容量(capacity)强迫变为某个数值。123capacity:一个容器最大可以存放多少个元素，即size最大是多少。size:当前容器有多少元素。当vector在插入一个元素时，会比较size和capacity, 当两者一样大时，代表容量已经被用完，开始重新分配空间。 如果我们在一开始就将vector的capacity设置为某个足够大的数值，就不会出现多次重新分配的情况，也就提升了效率。如，上述程序这样写就不会出现重新分配的情况了:12345vector&lt;int&gt; v;v.reserve(1000);for(int i = 0; i &lt;= 1000; i++) &#123; v.push_back(i);&#125; 注：这条策略同样适用于string. 当对效率敏感时，应注意map.insert 与 map::operator[]当增加一对新元素时，使用map的insert函数。当进行元素更新时，使用map的[]操作符。 因为当进行“增加”操作时，operator[]会有三 个函数调用：构造临时对象，撤销临时对象和对对象复制，而insert不会有；而对于更新操作，insert需要构造和析构对象，而operator[] 采用的对象引用，不会有这样的效率损耗. 排序 若需对vector, string, deque, 或 array容器进行全排序，你可选择sort或stable_sort； 若只需对vector, string, deque, 或 array容器中取得top n的元素，部分排序partial_sort是首选. 若对于vector, string, deque, 或array容器，你需要找到第n个位置的元素或者你需要得到top n且不关系top n中的内部顺序，nth_element是最理想的； 若你需要从标准序列容器或者array中把满足某个条件或者不满足某个条件的元素分开，你最好使用partition或stable_partition； 若使用的list容器，你可以直接使用partition和stable_partition算法，你可以使用list::sort代替sort和stable_sort排序。若你需要得到partial_sort或nth_element的排序效果，你必须间接使用。正如上面介绍的有几种方式可以选择。 容器的成员函数优先于算法若一个容器的成员函数与一个算法功能一致，则优先选择成员函数。因为成员函数是专门为这个容器编写的，因此与容器结合地更紧密，效率一般会更高。 推荐查询函数用法的网站 -&gt; Cplusplus reference","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://Humbertzhang.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://Humbertzhang.github.io/tags/STL/"}]},{"title":"CSAPP:系统级I/O","slug":"CSAPP第十章笔记-系统级I-O","date":"2017-10-02T14:41:25.000Z","updated":"2017-12-22T05:24:37.664Z","comments":true,"path":"2017/10/02/CSAPP第十章笔记-系统级I-O/","link":"","permalink":"http://Humbertzhang.github.io/2017/10/02/CSAPP第十章笔记-系统级I-O/","excerpt":"","text":"Unix I/O所有I/O设备都被模型化为文件, 因此所有输入输出都被当作文件读写， 也因此所有输入输出都可以用一致的方式(Unix I/O)来执行: 打开文件通过内核来打开一个文件，并返回相应的文件描述符．内核记录文件的所有信息打开文件的应用程序只需要记住描述符.每个进程一开始就有三个描述符:0(标准输入),1(标准输出),2(标准错误),因此其他描述符从3开始． 改变当前文件的字节偏移量将文件偏移量改为应有的偏移量. 读写文件读文件:从文件复制字节到内存，大于文件大小时返回EOF.写文件:从内存复制字节到文件，然后更新字节偏移量. 关闭文件内核关闭文件，释放打开文件时用的数据结构，使描述符重新可用.当进程中止时，内核都会关闭其打开的所有文件． 文件 普通文件包括文本文件(内含ASCII 或 Unicode)与二进制文件． 目录目录是包含一组链接的文件，每个链接都将一个文件名映射到一个文件（可为另一个目录） 套接字用来与另一个进程进行跨网络通信的文件 打开和关闭文件打开文件1int open(char *filename, int flags, mode_t mode) flags参数：可以使用|符号来一起使用多个参数． 参数 意义 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 读写 O_CREAT 若不存在创建一个截断的空文件 O_TRUNC 若文件已存在就截断 O_APPEND 每次写之前将文件位置到文件结尾 文件截断 : 有时候我们需要在文件尾端处截取一些数据以缩短文件。 mode参数：若为创建一个新文件(O_CREAT), 则可以指定访问权限. 关闭文件使用描述符即可关闭.1int close(int fd); 读写文件1234567#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t n);将文件中n个字符读到buf中ssize_t write(int fd, const void *buf, size_t n);将buf中n个字符写至fd所指文件中.ssize_t 为有符号大小size_t 为无符号大小 Robust I/O:健壮的IO包无缓冲的输入输出直接在文件与内存之间传输数据在将二进制数据读写至网络和从网络读写二进制数据时很有用12ssize_t rio_readn(int fd, void *usrbuf, size_t n);ssize_t rio_writen(int fd, void *usrbuf, size_t n); 有缓冲的输入输出在rio_t 结构体中的 rio_buf中存作为缓冲，之后再从中读取出来. rio_t 结构体1234567#define RIO_BUFSIZE 8192typedef struct &#123; int rio_fd; //与缓冲区绑定的描述符 int rio_cnt; //缓冲区还未读的字节数 char * rio_bufptr; //缓冲区中下一个要被读的字节的指针 char rio_buf[RIO_BUFSIZE]; //缓冲区&#125;rio_t; rio_readinitb函数 : 绑定fd与rio_t 结构体.123456void rio_readinitb(rio_t *rp, int fd)&#123; rp -&gt; rio_fd = fd; rp -&gt; rio_cnt = 0; //还未读的字节初始化为0 rp -&gt; rio_bufptr = rp -&gt; rio_buf; //将读取的指针指向缓冲区&#125; rio_read函数先从文件读到rio_t结构体缓存区，再memcpy到用户内存.因为这个函数定义的输入输出与Linux系统中的read函数一致，所以用它来替换上文无缓冲输入输出中的read函数即可得到他的有缓冲版本-&gt;rio_readnb.12345678910111213141516171819202122232425static ssize_t rio_read(rio_t * rp, char *usrbuf, size_t n)&#123; int cnt; while(rp-&gt;rio_cnt &lt;= 0)&#123; //若没有读到数据，则继续 rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf)); //将fd所指的文件传送sizeof(rp-&gt;rio_buf)个字符到rp-&gt;rio_buf所指的空间中.若成功则返回字符数给rio_cnt, 出错返回-1，无可读数据返回0． if(rp -&gt; rio_cnt &lt; 0)&#123; //对返回为-1作处理 if(errno != EINTR) return -1; &#125; else if(rp-&gt;rio_cnt == 0) //对未读做处理 return 0; else rp-&gt;rio_bufptr = rp -&gt; rio_buf; //一切正常则将读数据的指针指向保存数据的内存 &#125; /*从rio_t结构体中的缓存中复制 min(n, rp-&gt;rio_cnt) 个字节到用户内存中*/ cnt = n; if(rp -&gt; rio_cnt &lt; n) cnt = rp -&gt;rio_cnt; memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp -&gt; rio_bufptr += cnt; //移动指针 rp -&gt; rio_cnt -= cnt; //减少应读的字节数 return cnt;&#125; rio_readlineb函数 : 读取一行因为rio_readline跟rio_read共用的一个rp结构体因此只要在第一次if(rc = rio_read(rp,&amp;c,1) == 1)的时候在rp结构体中的rp-&gt;rio_cnt就已经不是0了，因此上一个函数就不需要做while(rp-&gt;rio_cnt&lt;=0)中所做的事情了，而是直接memcpy()来从rp-&gt;rio_bufptr中移动一个字符到usrbuf因此避免了每个字节都陷入内核12345678910111213141516171819202122232425ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)&#123; int n, rc; char c, *bufp = usrbuf; for(n = 1; n &lt;maxlen; n++)&#123; if((rc = rio_read(rp, &amp;c, 1)) == 1)&#123;// *bufp++ = c; if(c == '\\n')&#123; //是换行符号则字符数+1并停止 n++; break; &#125; &#125; else if(rc == 0)&#123; if(n == 1) return 0; else break; &#125; else return -1; &#125; *bufp = 0; //??? return n-1; //因为n从1开始，故n-1才为字节数目.&#125; 读取文件元数据元数据指用来表示数据的数据 12345678910111213141516int stat(const char *filename, struct stat *buf);//以文件名作为输入int fstat(int fd, struct stat *buf); //以文件描述符作为输入他们会将文件转换为如下结构体,这些也就是所谓文件元数据struct stat &#123; ... ... ino_t st_ino; /*inode*/ mode_t st_mode; /*文件类型与文件访问许可位*/ nlink_t st_nlink; /*hard links的number*/ uid_t st_uid; /*User ID of owner*/ gid_t st_gid; /*Group ID of owner*/ ... off_t st_size; /*Total Size in bytes*/ ... ...&#125; inode表示文件位置, 更多关于inode可以看inode-Wikipedia st_mode可以用以下宏谓词来确定文件类型:123S_ISREG(m) -&gt; m是一个普通文件吗?S_ISDIR(m) -&gt; m是一个目录文件吗?S_ISSOCK(M) -&gt; m是一个套接字吗? 读取目录内容opendir 函数123456#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);成功返回指向目录流的指针，出错返回NULL流 是对条目有序序列的一个抽象，这里指目录项的列表 readdir 函数12345678910#include &lt;dirent.h&gt;struct dirent *readdir(DIR *dirp);若成功，返回返回下一个目录项的指针若在该目录下没有更多的目录项或出错了，则返回NULL，并修改errno的值每个目录项的结构如下:struct dirent &#123; ino_t d_ino; /*inode number,文件位置*/ char d_name[256]; /*filename*/&#125;; closedir函数12#include &lt;dirent.h&gt;int closedir(DIR *dirp); 关闭目录流并释放资源. 大体来说，读取目录内容的流程为:1,使用opendir来得到一个指向目录流的指针.2,使用readdir来一个个读取目录中的所有项目直到返回NULL.3,再用closedir来关闭目录流.123456789101112131415int main(int argc, char **argv)&#123; DIR *streamp; struct dirent *dep; streamp = Opendir(argv[1]); errno = 0; while((dep = readdir(streamp)) != NULL)&#123; printf(\"Found file: %s\\n\", dep-&gt;d_name); &#125; if(errno != 0) unix_error(\"readdir error\"); Closedir(streamp); exit(0);&#125; 共享文件内核如何表示打开的文件内核用三个相关的数据结构来表示打开的文件 描述符表(descriptor table)每个进程都有自己的描述符表,表中每个表项由进程打开的文件描述符来索引的.每个打开的描述符表项指向文件表中的一个表项 文件表(file table)所有进程共用一个文件表,它表示所有打开的文件的集合.它包括的列有文件位置，引用计数,以及一个指向v-node表中对应表项的指针.内核会在一个表项的引用计数为0时删除一个表项. v-node 表同为所有进程共用一张表，每个表项包括st_mode, st_size等stat结构中的大多数信息.不同于inode, inode只是表示文件位置. 注1:tty可以理解为一个交互环境，如终端.注2: On Linux, the set of file descriptors open in a process can beaccessed under the path /proc/PID/fd/, where PID is the processidentifier. 父子进程如何共享打开文件列表调用fork()前只有父进程表指向文件表的指针,调用fork后子进程增加了对于文件表中相应文件的引用次数.而从file table到vnode table的引用是不受影响的. I/O重定向在shell中，可用 &gt; 符号来重定向输出到文件.另一种方式是使用dup2函数1234567#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);成功返回非负描述符, 出错返回-1.dup2()函数复制该进程的描述符表中的oldfd的表项到newfd表项.覆盖newfd之前的内容.如果newfd已经打开了,dup2()会在复制oldfd之前关闭newfd. .如图,dup(4,1)会将标准输出(fd = 1)重定向到(fd = 4),即指向fileB.之后fileA将会被关闭, file table到v-node table的引用会被删除, v-node table中对应项也会被释放. 标准I/O(＜stdio.h＞)包括: 打开关闭文件的函数:fopen(), fclose() 读写字节的函数:fread(), fwrite() 读写字符串:fgets(), fputs() 复杂格式化I/O:scanf(), printf()标准I/O库将一个打开的文件模型化一个流,即一个指向FILE类型的结构的指针.每个C程序在一开始就有三个打开的流:12345#include &lt;stdio.h&gt;extern FILE *stdin; 文件描述符为0extern FILE *stdout; 文件描述符为1extern FILE *stderr; 文件描述符为2因为Linux中一切皆文件，所以一开始也打开stdin, stdout, stderr三个文件. FILE类型的流是对文件描述符和流缓冲区(使开销较大的Linux I/O函数调用次数尽可能小)的抽象． 使用I/O函数的建议与限制本章讨论的所有I/O函数如下:可以看出标准I/O函数与RIO函数都是基于Unix I/O函数来实现的. 使用I/O函数的基本指导与建议: 只要有可能就使用标准I/O．对于磁盘与终端设备I/O来说, 标准I/O是首选. 不要使用scanf或rio_readlineb来读取二进制文件.因为二进制文件中可能有0xa字节，而他们在读取文本文件的函数中代表换行，但是在读取二进制文件过程中就会导致错误. 对网络套接字的I/O使用rio函数 在标准I/O流中又存在着一些限制: 限制一:跟在输出函数后的输入函数．如果没有清空缓存区的函数(fflush)或重置当前文件位置的函数(fseek, fsetpos, rewind)调用，不能这样. 限制二:跟在输入函数后的输出函数:若之间没有fseek, fsetpos, rewind的调用,且输入函数又不是自然结束，则不可在其后跟输出函数. 而因为lseek函数在套接字中为非法的，因此不建议在网络套接字的读取中使用标准I/O函数，而是建议使用RIO函数.可用sprintf在内存中格式化一个字符串, 再用rio_writen写.或是用rio_readlineb读取一个文本行，再用sscanf从文本行提取不同字符串.","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://Humbertzhang.github.io/tags/CSAPP/"},{"name":"CS基础","slug":"CS基础","permalink":"http://Humbertzhang.github.io/tags/CS基础/"},{"name":"Linux","slug":"Linux","permalink":"http://Humbertzhang.github.io/tags/Linux/"}]},{"title":"测试驱动开发流程","slug":"测试驱动开发流程-md","date":"2017-08-11T03:36:08.000Z","updated":"2017-08-11T03:53:12.276Z","comments":true,"path":"2017/08/11/测试驱动开发流程-md/","link":"","permalink":"http://Humbertzhang.github.io/2017/08/11/测试驱动开发流程-md/","excerpt":"","text":"测试驱动开发什么是测试驱动开发（TDD）测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。 测试驱动开发的好处 测试驱动开发可以使我们仔细思考需求，减少后期的修改 在测试驱动开发过程中，我们会对相应的功能进行分解与设计，可以提高代码的内聚性与复用性 测试驱动开发可以使我们快速找出Bug,并提高我们的修改代码的自信 测试驱动开发过程12345671） 明确当前要完成的功能。可以记录成一个 TODO 列表。2） 快速完成针对此功能的测试用例编写。3） 测试代码编译不通过。 4） 编写对应的功能代码。 5） 测试通过。 6） 对代码进行重构，并保证测试通过。 7） 循环完成所有功能的开发。 我们的开发流程1，确定API文档首先，后端应根据需求进行数据库的设计，API功能的确定以及API文档的编写。编写完API文档之后，应与一起开发的前端人员一起确定API文档中的各个API，反复修改直到达成约定。 2，编写项目骨架根据之前设计的数据库等，编写相应的models.py以及其他必不可少的组成部分，具体可见下面的实战。 3，测试驱动开发API根据测试开发的过程，编写测试以及API 实战在这里，我们会编写一个带有用户系统的，前后端分离的简单Demo.他的功能是当你在注册登录后，使用GET方法访问相应API时，他会返回用户名字．使用PUT方法访问相应API时，可以修改名字．你可以在我的github仓库中查看代码 1，确定API文档注册 URL Header Method /api/v1.0/signup/ 无 POST POST data(json):1234&#123; &quot;username&quot;: string, //用户名 &quot;password&quot;: string, //用户密码&#125; Return data(json):123&#123; &quot;created&quot;: int //用户ID&#125; 登录 URL Header Method /api/v1.0/signin/ 无 POST POST data(json):1234&#123; &quot;username&quot;: string, //用户名 &quot;password&quot;: string, //用户密码&#125; Return data(json):1234&#123; &quot;uid&quot;:Int &quot;token&quot;:String&#125; 获取用户名字 URL Header Method /api/v1.0/&lt;int:id&gt;/ Authorization:Basic Base64Token GET Return data(json):123&#123; &quot;username&quot;:String&#125; 修改用户名字 URL Header Method /api/v1.0/&lt;int:id&gt;/ Authorization:Basic Base64Token PUT PUT data(json):123&#123; &quot;username&quot;:String&#125; Return data(json):123&#123; &quot;message&quot;:&quot;modiry&quot;&#125; 2，编写项目骨架Demo的文件结构为：123456789101112.├── APIdoc.md├── Demo│ ├── app│ │ ├── api│ │ │ └── __init__.py│ │ ├── __init__.py│ │ └── models.py│ ├── config.py│ ├── manage.py│ └── requirements.txt└── README.md 根据仓库中的代码来完善好config.py manage.py requirements.txt model.py 以及各个__init__.py如果你是克隆的仓库，可以使用git checkout a1ff2d4 来切换到搭建完骨架之后 3，测试驱动开发API在manage.py 所在的文件夹下，创建test文件夹，在test文件夹下创建test.py． 根据仓库中的代码编写测试，并运行，得到预料中的False. 之后，根据在测试中所编写的测试用例完善api文件夹中的各个API,每次写完某个API之后就应运行一下测试(python manage.py test),判断是否符合预期．若要修改功能，也应先修改测试用例，再修改API. 你分别可以使用 git checkout &lt;HEAD_ID&gt; 来跳到相应的版本 History HEAD ID Test.py编写完成 cebecb4 Signup完成 f7c88dc Signin完成 0740636 Getname API完成 a75f76e ChangeName API完成 e3102c1 测试前不要忘记初始化数据库！123python manage.py db initpython manage.py db migratepython manage.py db upgrade Refrence : 浅谈测试驱动开发（TDD）","categories":[],"tags":[]},{"title":"使用Mysql_In_Docker为docker部署的Flask提供数据库支持","slug":"docker-compose部署MysqlInDocker+Flask","date":"2017-07-31T03:24:50.000Z","updated":"2017-12-21T08:49:38.489Z","comments":true,"path":"2017/07/31/docker-compose部署MysqlInDocker+Flask/","link":"","permalink":"http://Humbertzhang.github.io/2017/07/31/docker-compose部署MysqlInDocker+Flask/","excerpt":"","text":"目的：使用Docker部署的mysql来为flask提供数据支持 Step1- [拉取docker mysql镜像](#拉取docker-mysql镜像) Step2- [获取docker-mysql的内网地址](#获取docker-mysql的内网地址) Step3- [修改docker-compose.yml](#修改docker-composeyml) Step4- [部署flask与数据库初始化](#部署flask与数据库初始化) 目的：使用Docker部署的mysql来为flask提供数据支持 Step1拉取docker mysql镜像docker run --detach --name=test-mysql --env=&quot;MYSQL_ROOT_PASSWORD=mypassword&quot; mysql Step2获取docker-mysql的内网地址 docker inspect test-mysql | grep IPAddress 我得到的IPAddress为172.17.0.20 使用本地的mysql在其中加入新数据库,其中-h 后对应的即为上面的IPAdress ,-P对应mysql的默认端口3306. mysql -uroot -pmypassword -h 172.17.0.20 -P 3306 在数据库中输入 CREATE DATABASE TEST 加完后，添加config.py中相应的.env文件， MYSQL_URI=mysql://root:mypassword@mysql:3306/TEST Step3修改docker-compose.yml使用docker ps得到test-mysql的容器ID,根据容器的ID在docker-compose.yml中flask对应的容器中添加 external_links: - CONTAINER_ID:mysql Step4部署flask与数据库初始化之后使用 docker-compose build docker-compose up &amp; 来将项目部署起来 之后需要初始化数据库（仅初次部署需要） 在服务器上运行(注意需在manage.py中添加对应命令)： $ docker exec &lt;container id&gt; python manage.py db init $ docker exec &lt;container id&gt; python manage.py db migrate $ docker exec &lt;container id&gt; python manage.py db upgrade $ docker exec &lt;container id&gt; python manage.py insert_roles $ docker exec &lt;container id&gt; python manage.py add_test_admin $ docker exec &lt;container id&gt; python manage.py test 迁移数据库后（如果后续部署中修改了数据模型结构）在服务器上运行： $ docker exec python manage.py db migrate $ docker exec python manage.py db upgrade 此时该项目就可以正常与docker中的mysql相连了 Refrence: MySQL Docker Containers: Understanding the basics","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://Humbertzhang.github.io/tags/Docker/"}]},{"title":"半自动FlaskAPI测试－Judgement","slug":"半自动FlaskAPI测试－Judgement","date":"2017-07-14T05:16:34.000Z","updated":"2017-07-14T05:58:58.899Z","comments":true,"path":"2017/07/14/半自动FlaskAPI测试－Judgement/","link":"","permalink":"http://Humbertzhang.github.io/2017/07/14/半自动FlaskAPI测试－Judgement/","excerpt":"","text":"用途最近在写桂声测试的时候，发现对于Flask api的测试是有很多套路的，可以写一个东西来自动地将那些套路的东西填上，然后再由我们自己对那些非套路的东西人工修改，这样以来写测试的效率就会提高很多． 使用方法现在还没上传到pip那里（貌似pip在重构？怎么都传不上去），所以暂时只能clone下来judgement的仓库使用: git clone https://github.com/Humbertzhang/Judgement.git 克隆下来后仓库的结构是这样的： . ├── judgement.py ├── README.md └── test_apis ├── forgive.py ├── getinfo.py ├── __init__.py ├── signin.py ├── signup.py └── uploadtime.py 其中test_apis文件夹是用来测试使用的，例如下图：在实际使用中输入的API Floder Address为我们的api存放的文件夹．接着judgement便会自动地在其所在的文件夹为我们生成API的测试，存放在自动生成的testByJudgement文件夹里．judgement使用就是这样,肯定还有很多不足和可以改进的地方，欢迎 issue 和 pr. 实现方法主要便是调用了文件读写的api．读取api文件夹中每个文件，然后对每一行进行检查，如果该行中有@api.route()字样便识别为一个api的开始，然后跳过接下来带有＂＠＂，＂＃＂的行和空行，读取其api名字与方法，根据不同的方法来file.writelines不同的内容．","categories":[],"tags":[]},{"title":"模拟登录下获取Cookie","slug":"模拟登录下获取Cookie","date":"2017-05-20T16:51:10.000Z","updated":"2017-05-20T17:24:35.502Z","comments":true,"path":"2017/05/21/模拟登录下获取Cookie/","link":"","permalink":"http://Humbertzhang.github.io/2017/05/21/模拟登录下获取Cookie/","excerpt":"","text":"获取信息门户的Cookie时，我们需要动态的获取，以得到正确的Cookie.因为原来华师匣子课表等有数据库，故不需要此cookie,但获取成绩就需要这个Cookie了．学长给的获取cookie的示例因为需要Python3中的async，而之前monitor的代码都是基于Python2的，故不可以直接用，需要从新写一个Python2版本的．按照学长给的示例，需要3次Session的请求．在三次请求之后才可以得到有正确Cookie的session. 我的代码如下（最后还是有问题） 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsfrom pprint import pprintinfo_login_url = \"http://portal.ccnu.edu.cn/loginAction.do\"link_url = \"http://portal.ccnu.edu.cn/roamingAction.do?appId=XK\"login_ticket_url = \"http://122.204.187.6/xtgl/login_tickitLogin.html\"headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\",&#125;post_data = &#123; 'userName': 2016210942, 'userPass': 130395&#125; #将URL与header定义好s = requests.Session() #使用 requests 的 session类r = s.post(info_login_url,data = post_data,header=header) #发送第一次请求if r.text.split('\"')[1] == 'index_jg.jsp': #判断是否登录成功 r_second = s.get(link_url,timeout = 4) #第二次 r_third = s.get(login_ticket_url,timeout = 4) #第三次 ret = s.__dict__ #获得s对象的所有属性 pprint(ret) #在这里可以用pprint 打印出来．pprint可以将字典等类型比较清晰地打印出来． #然后会比较容易发现s对象有一个叫做 cookies 的键. cookies = ret['cookies'] #在这里可以type(cookies) ,发现其为&lt;class 'requests.cookies.RequestsCookieJar'&gt; #这时我们就可以看一下requests关于cookie的文档 #找到这个类,发现虽然它就像一个字典一样 #打印它的key,value,就可以比较容易发现我们需要的数据了 for key,value in cookies.iteritems(): print key,value jwcinfo = cookies['BIGipServerpool_jwc_xk']jsessionid = cookies.values()[1] #获取cookieslogin_info_header = &#123; 'Bigipserverpool_Jwc_xk':jwcinfo, 'Sid':'2016210942', 'Jsessionid':jsessionid, 'Authorization':\"Basic Base64(2016210942:130395)\" &#125; #但是用这一个header得到的状态码还是502...不知道那里错了... 直接print ret 1&#123;'cookies': &lt;RequestsCookieJar[Cookie(version=0, name='BIGipServerpool_jwc_xk', value='1028696256.20480.0000', port=None, port_specified=False, domain='122.204.187.6', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='JSESSIONID', value='320CA9B505D70D76A12D3D826BB6F20E', port=None, port_specified=False, domain='122.204.187.6', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='BIGipServerpool_portal', value='173058240.20480.0000', port=None, port_specified=False, domain='portal.ccnu.edu.cn', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='JSESSIONID', value='aaa5uKro_uGjW6WSg0MWv', port=None, port_specified=False, domain='portal.ccnu.edu.cn', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False)]&gt;, 'stream': False, 'hooks': &#123;'response': []&#125;, 'redirect_cache': &lt;requests.packages.urllib3._collections.RecentlyUsedContainer object at 0x7fb36c78de50&gt;, 'auth': None, 'trust_env': True, 'headers': &#123;'Connection': 'keep-alive', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'User-Agent': 'python-requests/2.13.0'&#125;, 'cert': None, 'params': &#123;&#125;, 'verify': True, 'proxies': &#123;&#125;, 'adapters': OrderedDict([('https://', &lt;requests.adapters.HTTPAdapter object at 0x7fb36ca53790&gt;), ('http://', &lt;requests.adapters.HTTPAdapter object at 0x7fb36ca53b90&gt;)]), 'max_redirects': 30&#125; pprint ret 12345678910111213&#123;'adapters': OrderedDict([('https://', &lt;requests.adapters.HTTPAdapter object at 0x7fb36ca53790&gt;), ('http://', &lt;requests.adapters.HTTPAdapter object at 0x7fb36ca53b90&gt;)]), 'auth': None, 'cert': None, 'cookies': &lt;RequestsCookieJar[Cookie(version=0, name='BIGipServerpool_jwc_xk', value='1028696256.20480.0000', port=None, port_specified=False, domain='122.204.187.6', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='JSESSIONID', value='320CA9B505D70D76A12D3D826BB6F20E', port=None, port_specified=False, domain='122.204.187.6', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='BIGipServerpool_portal', value='173058240.20480.0000', port=None, port_specified=False, domain='portal.ccnu.edu.cn', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False), Cookie(version=0, name='JSESSIONID', value='aaa5uKro_uGjW6WSg0MWv', port=None, port_specified=False, domain='portal.ccnu.edu.cn', domain_specified=False, domain_initial_dot=False, path='/', path_specified=True, secure=False, expires=None, discard=True, comment=None, comment_url=None, rest=&#123;&#125;, rfc2109=False)]&gt;, 'headers': &#123;'Connection': 'keep-alive', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'User-Agent': 'python-requests/2.13.0'&#125;, 'hooks': &#123;'response': []&#125;, 'max_redirects': 30, 'params': &#123;&#125;, 'proxies': &#123;&#125;, 'redirect_cache': &lt;requests.packages.urllib3._collections.RecentlyUsedContainer object at 0x7fb36c78de50&gt;, 'stream': False, 'trust_env': True, 'verify': True&#125; requests关于cookie的文档 打印&lt;class &#39;requests.cookies.RequestsCookieJar&#39;&gt;的key,value:1234BIGipServerpool_jwc_xk 1028696256.20480.0000JSESSIONID 320CA9B505D70D76A12D3D826BB6F20EBIGipServerpool_portal 173058240.20480.0000JSESSIONID aaa5uKro_uGjW6WSg0MWv","categories":[],"tags":[]},{"title":"Flask下解析requests返回的json数据","slug":"Flask下解析requests返回的json数据","date":"2017-05-15T13:20:11.000Z","updated":"2017-12-11T12:14:54.069Z","comments":true,"path":"2017/05/15/Flask下解析requests返回的json数据/","link":"","permalink":"http://Humbertzhang.github.io/2017/05/15/Flask下解析requests返回的json数据/","excerpt":"","text":"今天在完善ccnubox_monitor时发现需要利用返回的数据．所以学了一下Python里怎么解析json数据. 因为需要先添加一节课，然后拿到这节课的id，之后用在删除这节课的api中，所以我们就需要先拿到添加这节课时返回的json数据里面的id. 具体代码如下(一些密码之类的删去了) 1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8import requestsimport jsonfrom flask import jsonifylogin_header = &#123;'login':'header'&#125;#添加课程post_data=&#123; \"course\":\"test\", \"teacher\":\"test\", \"weeks\":\"1,2,3,4\", \"day\":\"星期1\", \"start\":\"1\", \"during\":\"1\", \"place\":\"9-11\", \"remind\":False &#125;resp07=requests.post(\"https://ccnubox.addclass.url\", json = post_data, headers = login_header)statu07 = resp07.status_code#print resp07.text#print type(resp07.text)json_data = resp07.json()#print json_data#print type(json_data)global class_id class_id = json_data[\"id\"]#print class_id#删除课程 ID 为课程IDresp09 = requests.delete(\"https://ccnubox.deleteclass.url/\"+str(class_id)+\"/\", headers = login_info_header )statu09=resp09.status_codeprint statu09 首先，利用requests的post方法发送一个添加课程的请求.这时候我们print 一下他的text,发现是{&quot;id&quot;: 814}然后print 一下他的type(resp07.text),发现是&lt;type &#39;unicode&#39;&gt;上网查阅之后，得知利用 requests 所得到的response是Response类，他有一个方法是 json所以，我们让 json_data = resp.json() .此时我以为resp.json()得到的还是json类型，然后想把它转化成python中的dict类型.但是怎么都弄不好，后来type(resp.json())发现返回的是：&lt;type &#39;dict&#39;&gt;也就是说，resp.json()就直接将json数据变成了dict类型，所以我们此时就可以直接用键值对来拿里面的东西了：class_id = json_data[&quot;id&quot;] .所以我们就可以在删除里面用class_id了：str(class_id)大概就是这样．","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://Humbertzhang.github.io/tags/Flask/"},{"name":"Python","slug":"Python","permalink":"http://Humbertzhang.github.io/tags/Python/"}]},{"title":"Ubuntu上shadowsocks+chrome翻墙指南","slug":"Ubuntu上shadowsocks-chrome翻墙指南","date":"2017-05-08T15:29:58.000Z","updated":"2017-12-21T08:49:55.305Z","comments":true,"path":"2017/05/08/Ubuntu上shadowsocks-chrome翻墙指南/","link":"","permalink":"http://Humbertzhang.github.io/2017/05/08/Ubuntu上shadowsocks-chrome翻墙指南/","excerpt":"","text":"安装shadowsocks（终端版） 配置Chrome浏览器 翻墙的日常 安装shadowsocks（终端版）终端内输入 apt-get update apt-get install python-pip pip install shadowsocks 配置Chrome浏览器SwitchyOmega 按照指示通过github上安装switchyOmega，导入备份． 设置代理服务器时，我的设置好了的GFWed截图为 之后再跟着SwitchyOmega上操作即可 翻墙的日常之后，在终端里面输入以下内容：sslocal -s 服务器ip -p 服务器端口 -l 1080 -k “密码”如: sslocal -s 111.111.111.111 -p 6379 -l 1080 -k &quot;keyword&quot; 即可翻墙．如果嫌麻烦可以写个简单的脚本:Shell脚本编程30分钟入门","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://Humbertzhang.github.io/tags/Ubuntu/"}]},{"title":"使用Docker部署ceph/demo","slug":"使用Docker部署ceph-demo","date":"2017-05-06T14:50:44.000Z","updated":"2017-12-11T12:13:36.428Z","comments":true,"path":"2017/05/06/使用Docker部署ceph-demo/","link":"","permalink":"http://Humbertzhang.github.io/2017/05/06/使用Docker部署ceph-demo/","excerpt":"","text":"环境：Ubuntu 16.04 安装Dockercurl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 使用阿里云镜像加速器阿里云镜像加速器按照指导修改文件 得到自己的IP与CDIRip -4 a 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 inet 10.135.186.15/18 brd 10.135.191.255 scope global eth0 valid_lft forever preferred_lft forever 3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default inet 172.17.0.1/16 scope global docker0 valid_lft forever preferred_lft forever 2中的10.135.186.15即为ip，10.135.186.15/18为对应CDIR 下载镜像运行： sudo docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=10.135.186.15 -e CEPH_PUBLIC_NETWORK=10.135.186.15/18 ceph/demo d3e4ead6c0ba4606201f9f861bd960f4c6d9376d6686714664489540b2843ce0 下载ceph/demo 针对ext4修改配置官方不建议采用ext4文件系统作为ceph的后端文件系统，如果采用，那么对于ext4的filesystem，应该在/etc/ceph/ceph.conf中添加如下配置： osd max object name len = 256 osd max object namespace len = 64 部署ceph仍然运行 sudo docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=10.135.186.15 -e CEPH_PUBLIC_NETWORK=10.135.186.15/21 ceph/demo d3e4ead6c0ba4606201f9f861bd960f4c6d9376d6686714664489540b2843ce0 参考: Docker从入门到实践－镜像加速器 Ceph cluster on Docker for testing ceph/demo Docker Hub地址","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://Humbertzhang.github.io/tags/Docker/"}]},{"title":"Python核心编程四、五","slug":"Python核心编程第四章","date":"2017-04-06T15:35:04.000Z","updated":"2017-12-21T08:49:45.455Z","comments":true,"path":"2017/04/06/Python核心编程第四章/","link":"","permalink":"http://Humbertzhang.github.io/2017/04/06/Python核心编程第四章/","excerpt":"","text":"切片 “is” 和 “==” 可变类型与不可变类型 除法 Random 切片string[start:end:steps] OR string[start:end]如： &gt;&gt;&gt; str &apos;abcdefghijklmn&apos; &gt;&gt;&gt; str[0:3] &apos;abc&apos; &gt;&gt;&gt; str[1:9:3] &apos;beh&apos; “is” 和 “==”“is” 比较的是两个对象的id“==” 比较的是两个对象的值且在Python中[-256,256]范围内的整数，无论谁等于他们，id 都一样因为在Python中令变量等于[-256,256]范围内的值只会用他们引用那些数ps:对象的三个属性，id,type,value &gt;&gt;&gt; a = 256 &gt;&gt;&gt; b = 256 &gt;&gt;&gt; c = 256.0 &gt;&gt;&gt; d = 256.0 &gt;&gt;&gt; e = 257 &gt;&gt;&gt; f = 257 &gt;&gt;&gt; a == b True &gt;&gt;&gt; c == d True &gt;&gt;&gt; e == f True &gt;&gt;&gt; a is b True &gt;&gt;&gt; c is d False &gt;&gt;&gt; e is f False 可变类型与不可变类型可变类型：列表 字典不可变类型：数字 字符串 元组这些不可变类型在改变他们的值时ID便会改变而可变类型在改变时则不会 除法&gt;&gt;&gt; 1/2 #普通除法 0 &gt;&gt;&gt; 1.0/2.0 0.5 &gt;&gt;&gt; from __future__ import division &gt;&gt;&gt; 1/2 0.5 &gt;&gt;&gt; 1//2 0 &gt;&gt;&gt; 1.0//2.0 0.0 &gt;&gt;&gt; -1//2 -1 Randomrandom.randrange(start,end) :返回(start,end)内的整数，即不包括两端random.randint(start,end):随机返回[start,end]内的整数random.uniform(start,end)：随机返回[strat,end]内的浮点数random.choice(sequence)：随机返回sequence内的一个元素","categories":[],"tags":[]},{"title":"URL状态监控","slug":"URL状态监控","date":"2017-03-25T04:53:00.000Z","updated":"2017-12-21T08:50:03.494Z","comments":true,"path":"2017/03/25/URL状态监控/","link":"","permalink":"http://Humbertzhang.github.io/2017/03/25/URL状态监控/","excerpt":"","text":"要做什么 1,向指定URL发送请求： requests2,将状态码保存在redis数据库中 ： redis3,定时启动 ： celerybeat4,返回给前端，以便生成图表： flask5,注意有时需要附加头部信息： HTTPAuthBasic6,一次性返回最近24小时数据 程序结构： demo ├── celerybeat.pid ├── celerybeat-schedule ├── demo2.py ├── make_celery.py └── monitor.py make_celery.py #用于帮助配置 monitor 中的 celery 123456789101112131415from __future__ import absolute_importfrom celery import Celeryimport redisdef make_celery(app): celery = Celery(app.import_name,broker=app.config['CELERY_BROKER_URL']) celery.conf.update(app.config) TaskBase = celery.Task class ContextTask(TaskBase): abstract = True def __call__(self,*args,**kwargs): with app.app_context(): return TaskBase.__call__(self,*args,**kwargs) celery.Task = ContextTask return celery monitor.py #监控程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#coding:utf-8from __future__ import absolute_importimport requestsimport base64import redisfrom requests.auth import HTTPBasicAuthfrom celery import Celeryfrom flask import Flask,jsonifyfrom celery.schedules import crontabfrom datetime import timedeltafrom os import sys,pathfrom make_celery import make_celeryfrom flask_script import Manager #每次检查间隔时间TIME_EVERY_CHECK=10#连接redispool = redis.ConnectionPool(host='127.0.0.1', port=6379, db=1)r = redis.StrictRedis(connection_pool=pool)#图书馆头部信息Passlib =\"2016000000:123456\"b64Vallib = base64.b64encode(Passlib)#初始化APPapp = Flask(__name__)url01=\"https://taobao.com\"url02=\"https://ccnubox.muxixyz.com/api/lib/login/\"#配置app.config.update( CELERY_BROKER_URL='redis://127.0.0.1:6379', CELERY_RESULT_BACKEND='redis://127.0.0.1:6379/0', #Timezone CELERY_TIMEZONE = 'Asia/Shanghai', #schedules CELERYBEAT_SCHEDULE = &#123; 'request_taobao':&#123; 'task': 'login_xinximenhu', 'schedule': timedelta(seconds = TIME_EVERY_CHECK), &#125;, 'login_library':&#123; 'task':'login_lib', 'schedule':timedelta(seconds = TIME_EVERY_CHECK), &#125; &#125;) celery = make_celery(app)#访问淘宝@celery.task(name='request_taobao')def request_taobao(): resp01 = requests.get(url01) statu01 = resp01.status_code r.set(url01,statu01)#登录CCNU图书馆 @celery.task(name='login_lib')def login_lib(): resp02= requests.get(url02,headers = &#123;\"Authorization\": \"Basic %s\" %b64Vallib&#125;) statu02 = resp02.status_code r.set(url02,statu02)@app.route(\"/\")def index(): return jsonify(&#123; url01:r.get(url01), url02:r.get(url02) &#125;)if __name__ =='__main__': app.run(debug=True) demo2.py #一次返回最近XXX时间内的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8 from __future__ import absolute_importimport requestsimport base64import redisfrom requests.auth import HTTPBasicAuthfrom celery import Celeryfrom flask import Flask,jsonifyfrom celery.schedules import crontabfrom datetime import timedeltafrom os import sys,pathfrom make_celery import make_celeryfrom flask_script import Manager #每次检查间隔时间TIME_EVERY_CHECK=3#Control loop argi = 0#返回数据的总数TOTAL = 20#redis链接池pool01 = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, db=1)pool02 = redis.ConnectionPool(host=&apos;127.0.0.1&apos;, port=6379, db=2)r01 = redis.StrictRedis(connection_pool=pool01)r02 = redis.StrictRedis(connection_pool=pool02)#图书馆头部信息Passlib =&quot;2016210942:123456&quot;b64Vallib = base64.b64encode(Passlib)#初始化APPapp = Flask(__name__)url01=&quot;https://taobao.com&quot;url02=&quot;https://ccnubox.muxixyz.com/api/lib/login/&quot;#配置app.config.update( CELERY_BROKER_URL=&apos;redis://127.0.0.1:6379&apos;, CELERY_RESULT_BACKEND=&apos;redis://127.0.0.1:6379/0&apos;, #Timezone CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;, #schedules CELERYBEAT_SCHEDULE = &#123; &apos;product&apos;:&#123; &apos;task&apos;: &apos;product&apos;, &apos;schedule&apos;: timedelta(seconds = TIME_EVERY_CHECK), &#125;, &apos;login_library&apos;:&#123; &apos;task&apos;:&apos;login_lib&apos;, &apos;schedule&apos;:timedelta(seconds = TIME_EVERY_CHECK), &#125;, &apos;controli&apos;:&#123; &apos;task&apos;:&apos;controli&apos;, &apos;schedule&apos;:timedelta(seconds = TIME_EVERY_CHECK), &#125; &#125;)app.config[&apos;JSON_AS_ASCII&apos;] = Falsecelery = make_celery(app) #木犀产品展示@celery.task(name=&apos;product&apos;)def product(): resp01 = requests.get(url01) statu01 = resp01.status_code r01.set(i,statu01)#登录CCNU图书馆 @celery.task(name=&apos;login_lib&apos;)def login_lib(): resp02= requests.get(url02,headers = &#123;&quot;Authorization&quot;: &quot;Basic %s&quot; %b64Vallib&#125;) statu02 = resp02.status_code r02.set(i,statu02)@celery.task(name=&apos;controli&apos;)def controli(): global i if i &lt; TOTAL-1: i = i+1 elif i == TOTAL-1: i = 0@app.route(&quot;/&quot;)def index(): return jsonify(&#123; &quot;木犀产品展示&quot;:[r01.get(k) for k in range(TOTAL)], &quot;登录图书馆&quot;:[r02.get(k) for k in range(TOTAL)] &#125;)if __name__ ==&apos;__main__&apos;: app.run(debug=True) 程序运行步骤 1,flask project: python monitor.py runserver2,redis: redis-server3,celery(main process): celery worker - -app monitor.celery - -loglevel=info4,celery(beat): celery beat - -app monitor.celery - -loglevel=info 运行效果","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"http://Humbertzhang.github.io/tags/Flask/"},{"name":"Python","slug":"Python","permalink":"http://Humbertzhang.github.io/tags/Python/"},{"name":"Celery","slug":"Celery","permalink":"http://Humbertzhang.github.io/tags/Celery/"}]}]}